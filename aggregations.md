
## Simple metric aggregation

Here simple query of metric aggregation is shown. ```sum```, ```avg```, ```min```, and ```max``` aggregations are shown below.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "total_sales": {
      "sum": {
        "field": "total_amount"
      }
    },
    "avg_sale": {
      "avg": {
        "field": "total_amount"
      }
    },
    "min_sale": {
      "min": {
        "field": "total_amount"
      }
    },
    "max_sale": {
      "max": {
        "field": "total_amount"
      }
    }
  }
}
```

```json
{
  "took" : 11,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "max_sale" : {
      "value" : 281.77
    },
    "avg_sale" : {
      "value" : 109.20961
    },
    "min_sale" : {
      "value" : 10.27
    },
    "total_sales" : {
      "value" : 109209.61
    }
  }
}

```

## Aggregations for common stats field

The common stats field can be generated by ```stats``` field.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "amount_stats": {
      "stats": {
        "field": "total_amount"
      }
    }
  }
}
```

```json
{
  "took" : 4,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "amount_stats" : {
      "count" : 1000,
      "min" : 10.27,
      "max" : 281.77,
      "avg" : 109.20961,
      "sum" : 109209.61
    }
  }
}

```


## Aggregations for distinct value

Number of distinct value can be generated by ```cardinality``` field. It is good to know that ```cardinality``` field produces approximate numbers.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "total_salesmen": {
      "cardinality": {
        "field": "salesman.id"
      }
    }
  }
}
```

```json
{
  "took" : 8,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "total_salesmen" : {
      "value" : 100
    }
  }
}

```


## Aggregations for number values

Number of values can be generated by ```value_count``` field.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "values_count": {
      "value_count": {
        "field": "total_amount"
      }
    }
  }
}
```

```json
{
  "took" : 3,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "values_count" : {
      "value" : 1000
    }
  }
}

```


# Simple bucket aggregation
Here simple query of bucket aggregation is shown. Here buckets are created by document's status field.``` missing``` field with ```min_doc_count``` is also passed so that bucket includes ```"N/A"``` values. ```order``` field just sorts the bucket and is returned.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "status_terms": {
      "terms": {
        "field": "status.keyword",
        "size": 20,
        "missing": "N/A",
        "min_doc_count": 0,
        "order": {
          "_key": "asc"
        }
      }
    }
  }
}
```

```json
{
  "took" : 6,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "status_terms" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [
        {
          "key" : "N/A",
          "doc_count" : 0
        },
        {
          "key" : "cancelled",
          "doc_count" : 196
        },
        {
          "key" : "completed",
          "doc_count" : 204
        },
        {
          "key" : "confirmed",
          "doc_count" : 192
        },
        {
          "key" : "pending",
          "doc_count" : 199
        },
        {
          "key" : "processed",
          "doc_count" : 209
        }
      ]
    }
  }
}

```

# Nested bucket Aggregation

Nested bucket aggregation is also supported by ES.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "status_terms": {
      "terms": {
        "field": "status"
      },
      "aggs": {
        "status_stats": {
          "stats": {
            "field": "total_amount"
          }
        }
      }
    }
  }
}
```

```json
{
  "took" : 4,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "status_terms" : {
      "doc_count_error_upper_bound" : 0,
      "sum_other_doc_count" : 0,
      "buckets" : [
        {
          "key" : "processed",
          "doc_count" : 209,
          "status_stats" : {
            "count" : 209,
            "min" : 10.27,
            "max" : 281.77,
            "avg" : 109.30703349282295,
            "sum" : 22845.17
          }
        },
        {
          "key" : "completed",
          "doc_count" : 204,
          "status_stats" : {
            "count" : 204,
            "min" : 10.93,
            "max" : 260.59,
            "avg" : 113.54058823529411,
            "sum" : 23162.28
          }
        },
        "..."
      ]
    }
  }
}

```


# Filtering bucket Aggregation

Filters can be applied to  bucket aggregation. Below show the simple filter applied to bucket aggregation.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "low_value": {
      "filter": {
        "range": {
          "total_amount": {
            "lt": 50
          }
        }
      },
      "aggs": {
        "avg_amount": {
          "avg": {
            "field": "total_amount"
          }
        }
      }
    }
  }
}
```

```json
{
  "took" : 5,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "low_value" : {
      "doc_count" : 164,
      "avg_amount" : {
        "value" : 32.59371951219512
      }
    }
  }
}

```


# Defining bucket rules with filter

ES also handles defining the bucket rules with filters as shown below.

```json
GET /recipe/_search
{
  "size": 0,
  "aggs": {
    "my_filter": {
      "filters": {
        "filters": {
          "pasta": {
            "match": {
              "title": "pasta"
            }
          },
          "spaghetti": {
            "match": {
              "title": "spaghetti"
            }
          }
        }
      },
      "aggs": {
        "avg_rating": {
          "avg": {
            "field": "ratings"
          }
        }
      }
    }
  }
}
```

```json
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 21,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "my_filter" : {
      "buckets" : {
        "pasta" : {
          "doc_count" : 9,
          "avg_rating" : {
            "value" : 3.4125
          }
        },
        "spaghetti" : {
          "doc_count" : 4,
          "avg_rating" : {
            "value" : 2.3684210526315788
          }
        }
      }
    }
  }
}

```


# Range bucket Aggregation

Range bucket aggregation creates buckets under specified range. Range also include ```data_range``` which works similar to range but intended to be used while working with data ranges.


```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "amount_distribution": {
      "range": {
        "field": "total_amount",
        "ranges": [
          {
            "to": 50
          },
          {
            "from": 50,
            "to": 100
          },
          {
            "from": 100
          }
        ]
      }
    }
  }
}

```

```json
{
  "took" : 7,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "amount_distribution" : {
      "buckets" : [
        {
          "key" : "*-50.0",
          "to" : 50.0,
          "doc_count" : 164
        },
        {
          "key" : "50.0-100.0",
          "from" : 50.0,
          "to" : 100.0,
          "doc_count" : 347
        },
        {
          "key" : "100.0-*",
          "from" : 100.0,
          "doc_count" : 489
        }
      ]
    }
  }
}

```

Similar to range ```date_range``` can be used while working with dates.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "purchased_ranges": {
      "date_range": {
        "field": "purchased_at",
        "format": "yyyy-MM-dd",
        "keyed": true,
        "ranges": [
          {
            "from": "2016-01-01",
            "to": "2016-01-01||+6M",
            "key": "first_half"
          },
          {
            "from": "2016-01-01||+6M",
            "to": "2016-01-01||+1y",
            "key": "second_half"
          }
        ]
      }
    }
  }
}
```

```json
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "purchased_ranges" : {
      "buckets" : {
        "first_half" : {
          "from" : 1.4516064E12,
          "from_as_string" : "2016-01-01",
          "to" : 1.4673312E12,
          "to_as_string" : "2016-07-01",
          "doc_count" : 481
        },
        "second_half" : {
          "from" : 1.4673312E12,
          "from_as_string" : "2016-07-01",
          "to" : 1.4832288E12,
          "to_as_string" : "2017-01-01",
          "doc_count" : 519
        }
      }
    }
  }
}

```

Similar to example of bucket aggregation, sub-aggregation can be added on the range field.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "purchased_ranges": {
      "date_range": {
        "field": "purchased_at",
        "format": "yyyy-MM-dd",
        "keyed": true,
        "ranges": [
          {
            "from": "2016-01-01",
            "to": "2016-01-01||+6M",
            "key": "first_half"
          },
          {
            "from": "2016-01-01||+6M",
            "to": "2016-01-01||+1y",
            "key": "second_half"
          }
        ]
      },
      "aggs": {
        "bucket_stats": {
          "stats": {
            "field": "total_amount"
          }
        }
      }
    }
  }
}

```

```json
{
  "took" : 7,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "purchased_ranges" : {
      "buckets" : {
        "first_half" : {
          "from" : 1.4516064E12,
          "from_as_string" : "2016-01-01",
          "to" : 1.4673312E12,
          "to_as_string" : "2016-07-01",
          "doc_count" : 481,
          "bucket_stats" : {
            "count" : 481,
            "min" : 10.27,
            "max" : 260.59,
            "avg" : 106.78817047817049,
            "sum" : 51365.11
          }
        },
        "second_half" : {
          "from" : 1.4673312E12,
          "from_as_string" : "2016-07-01",
          "to" : 1.4832288E12,
          "to_as_string" : "2017-01-01",
          "doc_count" : 519,
          "bucket_stats" : {
            "count" : 519,
            "min" : 10.7,
            "max" : 281.77,
            "avg" : 111.45375722543352,
            "sum" : 57844.5
          }
        }
      }
    }
  }
}

```

## Dynamically building buckets with histogram

To evenly create buckets (of ```25``` in this case), histograms can be used. ```min_doc_count``` can be used to limit the number of document a bucket might have.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "amount_distribution": {
      "histogram": {
        "field": "total_amount",
        "interval": 25,
        "min_doc_count": 1
      }
    }
  }
}
```

```json

{
  "took" : 7,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "amount_distribution" : {
      "buckets" : [
        {
          "key" : 0.0,
          "doc_count" : 42
        },
        {
          "key" : 25.0,
          "doc_count" : 122
        },

        "...",

        {
          "key" : 275.0,
          "doc_count" : 1
        }
      ]
    }
  }
}

```

Similar to range above, date can also be used to create histograms with the help of ```date_histogram```.

```json
GET /order/_search
{
  "size": 0,
  "aggs": {
    "orders_over_time": {
      "date_histogram": {
        "field": "purchased_at",
        "calendar_interval": "month"
      }
    }
  }
}
```

```json
{
  "took" : 11,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1000,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "orders_over_time" : {
      "buckets" : [
        {
          "key_as_string" : "2016-01-01T00:00:00.000Z",
          "key" : 1451606400000,
          "doc_count" : 78
        },
        {
          "key_as_string" : "2016-02-01T00:00:00.000Z",
          "key" : 1454284800000,
          "doc_count" : 72
        },

        "...",

        {
          "key_as_string" : "2016-12-01T00:00:00.000Z",
          "key" : 1480550400000,
          "doc_count" : 82
        }
      ]
    }
  }
}


```

## Using global Aggregation

Using global aggregation with ```global``` key to break out of specific bucket.

```json
GET /order/_search
{
  "query": {
    "range": {
      "total_amount": {
        "gte": 100
      }
    }
  },
  "size": 0,
  "aggs": {
    "all_orders": {
      "global": { },
      "aggs": {
        "stats_amount": {
          "stats": {
            "field": "total_amount"
          }
        }
      }
    }
  }
}
```

```json
{
  "took" : 2,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 489,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "all_orders" : {
      "doc_count" : 1000,
      "stats_amount" : {
        "count" : 1000,
        "min" : 10.27,
        "max" : 281.77,
        "avg" : 109.20961,
        "sum" : 109209.61
      }
    }
  }
}


```

## Aggregating over missing fields

Missing fields can also be aggregated by using ```missing``` field.

```json
GET /order/_doc/_search
{
  "size": 0,
  "aggs": {
    "orders_without_status": {
      "missing": {
        "field": "status.keyword"
      }
    }
  }
}
```
```json
{
  "took" : 129,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 1002,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "orders_without_status" : {
      "doc_count" : 2
    }
  }
}


```


## Aggregating over nested objects

For nested objects, aggregation can be done by using ```nested``` field.


```json
GET /department/_search
{
  "size": 0,
  "aggs": {
    "employees": {
      "nested": {
        "path": "employees"
      },
      "aggs": {
        "minimum_age": {
          "min": {
            "field": "employees.age"
          }
        }
      }
    }
  }
}
```


```json
{
  "took" : 0,
  "timed_out" : false,
  "_shards" : {
    "total" : 1,
    "successful" : 1,
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : {
    "total" : {
      "value" : 2,
      "relation" : "eq"
    },
    "max_score" : null,
    "hits" : [ ]
  },
  "aggregations" : {
    "employees" : {
      "doc_count" : 15,
      "minimum_age" : {
        "value" : 19
      }
    }
  }
}

```